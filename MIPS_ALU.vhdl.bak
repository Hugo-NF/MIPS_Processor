library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity MIPS_ALU is
	generic (WORD_SIZE : natural := 32);
	port (
			opcode :				 	in std_logic_vector(3 downto 0);
			oprA, oprB :			in std_logic_vector(WORD_SIZE-1 downto 0);
			output :					out std_logic_vector(WORD_SIZE-1 downto 0);
			zero, ovfl :			out std_logic			
	);
end MIPS_ALU;

architecture behavioral of MIPS_ALU is
	constant op_and: std_logic_vector(3 downto 0) := 		"0000";
	constant op_or: std_logic_vector(3 downto 0)  := 		"0001";
	constant op_add: std_logic_vector(3 downto 0) := 		"0010";
	constant op_addu: std_logic_vector(3 downto 0):= 		"0011";
	constant op_sub: std_logic_vector(3 downto 0) := 		"0100";
	constant op_subu: std_logic_vector(3 downto 0):= 		"0101";
	constant op_slt: std_logic_vector(3 downto 0) := 		"0110";
	constant op_sltu: std_logic_vector(3 downto 0):= 		"0111";
	constant op_nor: std_logic_vector(3 downto 0) := 		"1000";
	constant op_xor: std_logic_vector(3 downto 0) := 		"1001";
	constant op_sll: std_logic_vector(3 downto 0) := 		"1010";
	constant op_srl: std_logic_vector(3 downto 0) := 		"1011";
	constant op_sra: std_logic_vector(3 downto 0) := 		"1100";
	constant op_rtr: std_logic_vector(3 downto 0) := 		"1101";
	constant op_rtl: std_logic_vector(3 downto 0) := 		"1110";
	
	process ALU(opcode, oprA, oprB)
	begin
		variable temp_sub: std_logic_vector(WORD_SIZE-1 downto 0) := std_logic_vector(signed(oprA) - signed(oprB));
		variable temp_out: std_logic_vector(WORD_SIZE-1 downto 0);
		output <= temp_out;
		
		if(temp_sub = X"00000000") 
			then zero <= '1' 
			else zero <= '0';
		end if;
		
		case opcode is
			when op_and =>
				temp_out := A and B;
		
		end case;
	end ALU;
	
end behavioral;